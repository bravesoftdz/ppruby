# Пакет ppRuby

<img src="https://raw.github.com/shikhalev/ppruby/master/img/logo.png" align="right">

Пакет `ppRuby` предоставляет доступ к [Ruby API][api] для языка Free Pascal.
Использовать его можно для двух основных задач:
* Написание библиотек расширения для Ruby;
* Встраивание Ruby в программы на Free Pascal / Lazarus в качестве скриптового
  языка.

В первом случае понадобится только `ruby.pas` скомпилированный в [статическом
режиме](#Режимы-условной-компиляции). Во втором будет лучше (хотя и 
необязательно) использовать
прочие модули пакета, которые предоставляют разнообразные утилиты для удобной
работы, а также механизм конвертации pascal-объектов в Ruby, автоматически
транслирующий published-свойства.

## Введение

### Состав пакета

* Каталог `demo` — содержит небольшой демонстрационный проект.
  * Подкаталог `rb` — скрипты (`rb/*.rb`), предназначенные для запуска в демо-проекте.
    По мере расширения возможностей пакета этот подкаталог также будет 
    дополняться.
  * Файлы: `aboutform.{lfm,pas}`, `demo.{ico,lpi,lpr}`, `mainform.{lfm,pas}` —
    собственно исходные файлы демо-проекта.
* Каталог `doc` и файлы `doc/*.md` — настоящая документация.
* Каталог `img` и файлы `img/logo.{png,xcf}` — логотип проекта.
* Каталог `src` — собственно исходные файлы пакета.
  * `rbopts.inc` — включаемый файл, определяющий существенные для компиляции
    параметры. Включается во все модули пакета.
  * `rbdefs.inc` — включаемый файл, доопределяющий переменные 
    [условной компиляции](#Режимы-условной-компиляции)
    в зависимости от уже заданных. Требуется только для `ruby.pas`, вынесен
    в отдельную сущность ради логического разделения.
  * `ruby.pas` — определяет необходимые типы и предоставляет доступ к API.
    В дополнение к этому определяет процедуры инициализации, финализации 
    и управление выбором версии в случае динамической загрузки библиотеки.
    Для удобства большая часть кода вынесена во включаемые файлы:
    * `rbtypes.inc` — определения типов, используемых функциями API.
    * `rbdynintf.inc` — интерфейсная часть для динамической загрузки.
    * `rbstatintf.inc` — интерфейс статической загрузки.
    * `rbmacrointf.inc` — интерфейс для `inline`-функций, представленных
      в оригинальном API (на языке C) как макросы.
    * `rbdynimpl.inc` — реализация вспомогательных функций, необходмых для
      динамической загрузки.
    * `rbmacroimpl.inc` — реализация функций-«макросов».
    * `rbdyninit.inc` — инициализация механизма динамической загрузки.
  * `rbtools.pas` — базовый вспомогательный модуль, предоставляющий функции
    конвертации данных основных типов языка Pascal в объекты Ruby, а также
    «обертки» над некоторыми функциями API, необходимые для удобного и 
    безопасного использования в pascal-контексте (см. ниже подраздел 
    «[Исключения и контекст](#Исключения-и-контекст)»).
  * `rbobjects.pas` — определяет конвертацию в Ruby объектов и классов Pascal.
    При конвертации классов автоматически создаются ruby-атрибуты, 
    соответствующие `published`-свойствам.
  * `rbclasses.pas`, `rbdialogs.pas`, `rbforms.pas` — определяют ruby-методы
    для `public`-свойств и методов классов, расположенных в соостветствующих
    стандартных модулях (т.е. `Classes`, `Dialogs` и `Forms`). В настоящий
    момент `RbClasses` реализован практически полностью, тогда как два других —
    по минимуму. Эти модули будут однозначно расширяться в дальнейшем, а также
    дополняться аналогами для других стандартных модулей FPC и Lazarus.
  * `rubyconnection.pas` — определяет компонент, позволяющий задать параметры
    подключения к библиотеке в design-time;
    * `rubyconnection_icon.lrs` — значок к нему.
  * `pprubydsgn.pas` — регистрация компонентов в IDE. Пока только 
    `TRubyConnection`, в дальнейшем вся регистрация будет складываться туда,
    чтобы не замусоривать модули, используемые и в run-time.
  * `ppruby.lpk` и `ppruby.pas` — собственно пакет.

### Режимы условной компиляции

* `RUBY_STATIC` — устанавливает статический режим. Т.е. используется раннее 
  связывание — функции и переменные Ruby API определяются как `external`.
  В этом режиме имеют смысл также следующие определения:

  * `RUBY19`, `RUBY20` и `RUBY21`, определяющие версию библиотеки. Последний 
    вариант введен, но пока не реализован (скорее всего, работа с версией 
    Ruby 2.1 начнется, когда она появится в репозиториях Gentoo).

  * `RUBY_LIB` — макрос, определяющий имя библиотеки, автоматически 
    устанавливается в зависимости от версии и операционной системы (согласно
    определениям `DARWIN`, `UNIX` кроме `DARWIN` и `WINDOWS`).

    Имя библиотеки для `UNIX` соостветствует именованию в дистрибутиве Debian 
    и производных, но можно переключиться на именование Gentoo, задав `GENTOO` 
    соответственно. Если вы используете другой дистрибутив с отличающимся
    вариантом имени файла библиотеки (или другую unix-based систему, например,
    FreeBSD), пожалуйста, сообщите. Корректно задать имя библиотеки можно
    в файле `rbdefs.inc`.
    
* `RUBY_DYNAMIC` — включается по умолчанию. В этом случае функции API 
  определяются как процедурные переменные и инициализируются вместе с прочими
  переменными при загрузке. Кроме того, включается система выбора версий.

  Надо заметить, что в разных версиях Ruby некоторые константы API имеют
  разное значение. Поэтому в динамическом режиме они являются переменными,
  что может принести некоторые неудобства и замедление.
  
В целом, модуль `Ruby` организован так, чтобы извне него не было необходимости
знать, в каком режиме он скопилирован, и даже с какой версией... Для последнего,
правда, *пришлось отказаться от поддержки Ruby 1.8*, поскольку там очень большие
различия в API, константах, принципах работы с кодировками и т.д.

## Использование

### Создание расширений

Создание расширений для Ruby не было основной задачей данного пакета, поэтому
все, что он дает — доступ к API. Как им воспользоваться — см. [документацию Ruby][api].
Специфически же для FPC и ppRuby нужно добавить следующее:
* Обязательна компиляция в статическом варианте, поскольку загрузкой будет 
  управлять сторона Ruby.
* Модули для конвертации классов и объектов в принципе применимы, но следует
  учитывать, что время жизни объектов так же должно управляться со стороны Ruby.
* Крайне важно обеспечить «непересечение» обработки исключений Pascal и Ruby. См. 
  ниже подраздел «[Исключения и контекст](#Исключения-и-контекст)».

### Встраиваемый скриптинг

Настоящий пакет предназначен для того, чтобы максимально упростить именно 
добавление Ruby как скриптового движка в проекты на Lazarus. Достаточно передать
каким-то образом, например, задав глобальную переменную, объект в Ruby, а затем
подать текст скрипта на выполнение. Например, перебор компонентов формы можно
организовать так:

```Pascal
uses
  ..., RbTools, RbObjects, RbClasses;
  
...
rb_gv_set('form', Obj2Val(frmMain));
pp_eval(script);
```

Где в переменной `script` находится что-то типа:

```Ruby
$form.each do |cmp|
  if cmp.respond_to? :caption
    cmp.caption = cmp.name
  end
end
```

Подключив же еще и модуль `RbForms` получим «общую точку доступа» — 
`Pascal::Forms.application`. Тогда перебор форм приложения может 
выглядеть так:

```Ruby
# метод application объявлен как module_function,
# чтобы не писать каждый раз имя модуля, подмешаем
# его в глобальный объект
extend Pascal::Forms

application.each do |form|
  form.caption = "Form: #{form.name}"
end
```

Дополнительно возможен перехват вывода, через установку глобальной 
переменной `$stdout` (и, возможно, `$stderr`) в специальное значение,
получаемое конвертацией интерфейса `IOutput`, определенного 
в `RbObjects`. Этот интерфейс, например, реализует `TRubyConnection`,
перенаправляя вывод в выбранный компонент. Подменив таким образом
стандартный вывод, можно спокойно использовать в скриптах привычные
`puts`, `p` и так далее. Результат можно видеть в демо.

### Исключения и контекст

## Справочная информация

### Модуль `Ruby`

### `RbTools` и `RbObjects`

[api]: http://rubydoc.info/stdlib/core/file/README.EXT
